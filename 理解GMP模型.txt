------------------------------------------
g, m, p 的定义都在 runtime/runtime2.go
type g struct {
}
主要成员：
stack: 栈空间的起始和结束为止
stackguard0：协程的栈的阀值， 超过这个值就要栈扩张了
stackguard1：系统调用的栈的阀值， 超过这个值就要栈扩张了
可见， 协程虽然能系统调用， 但系统调用的栈不会用协程的栈

g是goroutine的缩写， 一个main也是一个goroutine, 可以理解为等待运行或正在运行的任务。
goroutine包括新建，恢复，暂停。
每个g都会放到运行队列里，m会从这个运行队列取出g. m只有把g运行完，或者让g暂停， m才会去队列取下一个g。
g的状态有：
刚被创建还未被初始化的状态idle,
放在运行队列， 还没被m取出的状态runnable
正在被m运行行的状态running
系统调用的执行状态syscall， 此时运行该g的m让出p
等待状态waiting， 不在运行队列， 应该在通道的等待队列
还有两个状态， 待以后理解

m是machine的缩写，是运行在机器上的运行实体，目前版本的go来看，一个m就是一个系统线程。
m需要一个p来运行g , p代表运行时需要的资源， m运行的代码分为两部分， 一是go代码， 一是系统调用，
系统调用会阻塞， 这个m也就阻塞了，这个m就会让出p 给其他的m,  所以m的数量不会是一个，
m的数量不能太多，不能太少
m 的描述结构体中没有标记状态的成员
m的情况分为：
拥有P的时候，1. 正在从运行队列获取G， 2. 正在运行G的非系统调用部分，
和没拥有p的时候，1. 运行G中的系统调用部分， 2. m没有需要运行的G， m进入休眠， 放入空闲M链表

p是process的缩写，p是m所独享的资源，在同一个时间点，一个p只能被一个m使用，一个p可以为一个cpu核。
p的数量决定了可以同时执行的m的数量的最大值。
比如p的数量是2， 那么最多有两个m同时运行，可以有超过两个的m存在， 但最多有两个m同时运行。
因为p只能被一个m使用， m内的goroutine可以共享p资源。
P的状态有：
P的状态是随m而动的，
1. 所有的m都休眠了，p会加入空闲p链表，此时为空闲状态idle
2. g在运行状态， 对应m使用的p也在运行状态
3. g在系统调用状态， 对应m使用的p也在系统调用状态
4. gc的stw期间的，p在gcstop状态

每个P都有一个运行队列， g就是要放到这个运行队列， 然后m从这个队列取出m， 运行。
g 有多个运行队列可以选择， 优先选择当前p的运行队列。
关于一个核上到底可以有几个p还有待理解
m去取G时， 也是优先去取当前p的运行队列上的g, 当前p表示当前m所在的核对应的p。

------------------------------------------------------------------------------
函数返回值， 把所有的返回值返回到一个栈中， 如果返回的结构体很大， 会影响性能。

TLS: thread local storage, 代表每个线程的本地数据， 是每个线程所独有的。
TLS的地址存放在FS寄存器里， 线程切换时 ， FS跟着一起切换。
go 访问此寄存器就可得到线程本地数据， 即M的本地数据。

栈扩张：因为每个协程有自己的栈空间，协程可以大量创建， 所以协程刚开始的栈限定为2k
根据需要， 可以在协成运行一段一段时间，扩张栈， 扩张时， 是完全分配一个新栈，然后把旧栈里的内容拷过去。



------------------------------------------------------------------------------
关于M0，G0
M0 是第一个启动的线程
G0
每个协程都有自己专门的G,
有个G0不属于任何应用协程， 而是属于M的
每个M都有自己专有的G0， 因为一个M会有很多G等着他调度， M就把调度哪个G的这个事交给G0来做。


m理解为执行g的线程
sched: 被中断时，保护的现场数据， 包括pc寄存器里的值
atomicstatus:  g的状态标记
链表指针
被中断，重新执行时， 是否需要回到原来的M

m的成员
type m struct {
}
负责调度的g0， 当前正在被运行的g, 当前所拥有的p， 唤醒后重新拥有的p 用nextp表示

p的成员：
p的状态标记， 拥有这个p的m， 内存分配器， g运行的准备出队的队列， g运行的准备入队的队列